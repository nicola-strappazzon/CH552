/******************************************************************************
* File Name          : ch552.h
* Author             : Nicola Strappazzon C.
* Version            : V1.0
* Date               : 2023/12/27
* Description        : Header file for CH552 microcontrollers.
*******************************************************************************/

#ifndef __CH552_H__
#define __CH552_H__

#include <compiler.h>

#define FREQ_SYS 24000000 // Default clock frequency.

#define MASK_T1_MOD 0x30 // Bit mask of timer1 mode
#define MASK_T0_MOD 0x03 // Bit mask of timer0 mode

// Registers:
SFR(CLOCK_CFG, 0xB9); // System clock configuration register.
SFR(P3,        0xB0); // P3 port input & output.
SFR(P3_DIR_PU, 0x97); // P3 port direction control and pull up enable  register.
SFR(P3_MOD_OC, 0x96); // P3 port output mode register.
SFR(PCON,      0x87); // Power control register (in power on reset state).
SFR(PIN_FUNC,  0xC6); // Pin function selection register.
SFR(PWM_CK_SE, 0x9E); // PWM clock setting register.
SFR(PWM_CTRL,  0x9D); // PWM control register.
SFR(PWM_DATA1, 0x9C); // PWM1 data register.
SFR(PWM_DATA2, 0x9B); // PWM2 data register.
SFR(SAFE_MOD,  0xA1); // Safe mode control register (write only).
SFR(SBUF,      0x99); // UART0 data register.
SFR(SCON,      0x98); // UART0 control register.
SFR(T2CON,     0xC8); // Timer2 control register.
SFR(T2MOD,     0xC9); // Timer2 mode register.
SFR(TCON,      0x88); // Timer0/1 control register.
SFR(TH1,       0x8D); // Timer1 count high bit.
SFR(TMOD,      0x89); // Timer0/1 mode register.

// Power Control Register (PCON):
SBIT(SMOD,       0x87, 7); // When the UART0 baud rate is generated by timer 1, select the communication baud rate of UART0 mode 1, 2 and 3:
                           // - 0: Slow mode.
                           // - 1: Fast mode.
SBIT(bRST_FLAG1, 0x87, 5); // Last reset flag high bit 0.
SBIT(bRST_FLAG0, 0x87, 4); // Last reset flag low bit 1.
SBIT(GF1,        0x87, 3); // General flag bit 1. User-defined. Reset and set by software.
SBIT(GF0,        0x87, 2); // General flag bit 0. User-defined. Reset and set by software.
SBIT(PD,         0x87, 1); // Sleep mode enable. Sleep after set to 1. Automatically reset by hardware after wakeup.

// System clock configuration register (CLOCK_CFG), only can be written in safe mode:
SBIT(bOSC_EN_INT,     0xB9, 7); // Internal clock oscillator enable:
                                // - 1: Internal clock oscillator enabled, and select the internal clock.
                                // - 0: Internal clock oscillator disabled, and select the external crystal oscillator to provide the clock.
SBIT(bOSC_EN_XT,      0xB9, 6); // External crystal oscillator enable:
                                // - 1: P1.2/P1.3 pin used as XI/XO and the oscillator enabled. A quartz crystal or ceramic oscillator needs to be externally connected between the XI and XO.
                                // - 0: External oscillator disabled.
SBIT(bWDOG_IF_TO,     0xB9, 5); // Watch dog timer interrupt flag
                                // - 1: Interrupt triggered by the timer overflow signal.
                                // - 0: No interrupt.
                                // The bit is automatically reset when the watchdog count register (WDOG_COUNT) is reloaded or after entering the corresponding interrupt service program.
SBIT(bROM_CLK_FAST,   0xB9, 4); // flash-ROM reference clock frequency selection:
                                // - 0: Normal (if Fosc>=16MHz).
                                // - 1: Speed up (if Fosc<16MHz).
SBIT(bRST,            0xB9, 3); // RST pin state input bit.
SBIT(MASK_SYS_CK_SEL, 0xB9, 2); // System clock selection, [2:0]:
//                 |   System clock   | Relation with crystal | Fsys when        |
// MASK_SYS_CK_SEL | frequency (Fsys) |    frequency (Fxt)    | Fosc=24MHz       |
// ================|==================|=======================|==================|
// 000             |Fpll / 512        |Fxt / 128              |187.5KHz          |
// 001             |Fpll / 128        |Fxt / 32               |750KHz            |
// 010             |Fpll / 32         |Fxt / 8                |3MHz              |
// 011             |Fpll / 16         |Fxt / 4                |6MHz              |
// 100             |Fpll / 8          |Fxt / 2                |12MHz             |
// 101             |Fpll / 6          |Fxt / 1.5              |16MHz             |
// 110             |Fpll / 4          |Fxt / 1                |24MHz             |
// 111             |Fpll / 3          |Fxt / 0.75             |Reserved, disabled|
// -------------------------------------------------------------------------------

// UART0 Control Register (SCON):
SBIT(SM0, 0x98, 7); // UART0 working mode selection bit 0:
                    // - 0: 8-bit data asynchronous communication.
                    // - 1: 9-bit data asynchronous communication.
SBIT(SM1, 0x98, 6); // UART0 working mode selection bit 1:
                    // - 0: Fixed baud rate.
                    // - 1: Variable baud rate, which is generated by timer T1 or T2.
SBIT(SM2, 0x98, 5); // UART0 multi-device communication control bit:
                    // In mode 2 and mode 3,
                    //   When SM2=1,
                    //     If RB8 is 0, RI is not set to 1 and the reception is invalid.
                    //     If RB8 is 1, RI is set to 1 and the reception is valid.
                    //   When SM2=0, no matter RB8 is 0 or 1, RI is set when receiving data and the reception is valid.
                    // In mode 1, if SM2=1, only when the active stop bit is received can the reception be valid;
                    // In mode 0, the SM2 bit must be set to 0.
SBIT(REN, 0x98, 4); // UART0 receive enable bit:
                    // - 0: Receive disabled.
                    // - 1: Receive enabled.
SBIT(TB8, 0x98, 3); // The 9th bit of the transmitted data:
                    // In modes 2 and mode 3, TB8 is used to write the 9th bit of the transmitted data, which can be a parity bit.
                    // In multi-device communication, it is used to indicate whether the host sends an address byte or a data byte. Data byte when TB8=0, and address byte when TB8=1.
SBIT(RB8, 0x98, 2); // The 9th bit of the received data:
                    // In mode 2 and 3, RB8 is used to store the 9th bit of the received data.
                    // In mode 1, if SM2=0, RB8 is used to store the received stop bit.
                    // In mode 0, RB8 is not used.
SBIT(TI,  0x98, 1); // Transmit interrupt flag bit. Set by hardware at the end of a data byte transmission. It requires software to reset.
SBIT(RI,  0x98, 0); // Receive interrupt flag bit. Set by hardware at the end of a data byte reception. It requires software to reset.

// Timer/Counter 0/1 Mode Register (TMOD):
SBIT(bT1_GATE,  0x89, 7); // Gate control enable bit. This bit controls whether the Timer1 startup is affected by INT1:
                          // - 0: Whether the timer/counter 1 is started is independent of INT1.
                          // - 1: It is started only when the INT1 pin is at high level and TR1 is 1.
SBIT(bT1_CT,    0x89, 6); // Timing/counting mode selection bit:
                          // - 0: It works in timing mode.
                          // - 1: It works in counting mode. Falling edge on T1 pin selected as the clock.
SBIT(bT1_M1,    0x89, 5); // Timer/counter 1 mode selection high bit.
SBIT(bT1_M0,    0x89, 4); // Timer/counter 1 mode selection low bit.
SBIT(bT0_GATE,  0x89, 3); // Gate control enable bit. This bit controls whether the Timer0 startup is affected by INT0.
                          // - 0: Whether the timer/counter 0 is started is independent of INT0.
                          // - 1: It is started only when the INT0 pin is at high level and TR0 is 1.
SBIT(bT0_CT,    0x89, 2); // Timing/counting mode selection bit:
                          // - 0: It works in timing mode.
                          // - 1: It works in counting mode. Falling edge on T0 pin selectd as the clock.
SBIT(bT0_M1,    0x89, 1); // Timer/counter 0 mode selection high bit.
SBIT(bT0_M0,    0x89, 0); // Timer/counter 0 mode selection low bit.

// Timer/Counter 0/1 Control Register (TCON):
SBIT(TF1, 0x88, 7); // Timer1 overflow interrupt flag bit. Automatically cleared after it enters Timer1 interrupt.
SBIT(TR1, 0x88, 6); // Timer1 startup/stop bit. Set to 1 to startup. Set and cleared by software.
SBIT(TF0, 0x88, 5); // Timer0 overflow interrupt flag bit. Automatically cleared after it enters Timer0 interrupt.
SBIT(TR0, 0x88, 4); // Timer0 startup/stop bit. Set to 1 to startup. Set and cleared by software.
SBIT(IE1, 0x88, 3); // INT1 interrupt request flag bit. Automatically cleared after entering INT1 interrupt.
SBIT(IT1, 0x88, 2); // INT1 trigger mode control bit:
                    // - 0: INT1 triggered by low level.
                    // - 1: INT1 triggered by falling edge.
SBIT(IE0, 0x88, 1); // INT0 interrupt request flag bit. Automatically cleared after it enters INT0 interrupt.
SBIT(IT0, 0x88, 0); // INT0 trigger mode control bit:
                    // 0: INT0 triggered by low level.
                    // 1: INT0 triggered by falling edge.

// Timer/counter 2 control register (T2CON):
SBIT(TF2,    0xC8, 7); // Timer2 overflow interrupt flag when bT2_CAP1_EN=0 When the Timer2 counts of all 16 bits change from 1 to 0, this overflow flag is set to 1, which requires software to reset. When RCLK=1 or TCLK=1, the bit is not set to 1.
SBIT(CAP1F,  0xC8, 7); // Timer2 capture 1 interrupt flag when bT2_CAP1_EN=1. It is triggered by the active edge on T2, which requires software to reset.
SBIT(EXF2,   0xC8, 6); // Timer2 external trigger flag. It is triggered by T2EX active edge and set to 1 when EXEN2=1, which requires software to reset.
SBIT(RCLK,   0xC8, 5); // UART0 receive clock selection:
                       // - 0: Timer1 overflow pulse selected to generate baud rate.
                       // - 1: Timer2 overflow pulse selected to generate the baud rate.
SBIT(TCLK,   0xC8, 4); // UART0 transmit clock selection:
                       // - 0: Timer1 overflow pulse selected to generate baud rate.
                       // - 1: Timer2 overflow pulse selected to generate the baud rate.
SBIT(EXEN2,  0xC8, 3); // T2EX trigger enable bit:
                       // - 0: Ignore T2EX.
                       // - 1: Reload or capture enabled to be triggered by T2EX active edge.
SBIT(TR2,    0xC8, 2); // Timer2 startup/stop bit 0. Set to 1 to start. Set and cleared by software.
SBIT(C_T2,   0xC8, 1); // Timer2 clock source selection bit:
                       // - 0: Internal clock selected.
                       // - 1: Edge count based on falling edge on T2 pin selected.
SBIT(CP_RL2, 0xC8, 0); // Timer2 function selection bit. This bit should be forced to be 0 if RCLK or TCLK is 1:
                       // - 0: Timer2 selected as timer/counter to automatically reload the initial value of the count when the counter overflows or T2EX level changes.
                       // - 1: Timer2 capture 2 function enabled. The active edge on T2EX is captured.

// Timer/counter 2 mode register (T2MOD):
SBIT(bTMR_CLK,    0xC9, 7); // Fastest clock mode enable of T0/T1/T2 timer which has selected fast clock:
                            // - 1: Fsys without division as the count clock.
                            // - 0: Divided clock selected.
                            // This bit has no effect on the timer that selects the standard clock.
SBIT(bT2_CLK,     0xC9, 6); // Timer2 internal clock frequency selection bit:
                            // - 0: Standard clock selected. Fsys/12 when in timing/counting mode. Fsys/4 when in UART0 clock mode.
                            // - 1: Fast clock selected. Fsys/4 (bTMR_CLK=0) or Fsys (bTMR_CLK=1) when in timing/counting mode. Fsys/2 (bTMR_CLK=0) or Fsys (bTMR_CLK=1) when in UART0 clock mode.
SBIT(bT1_CLK,     0xC9, 5); // Timer1 internal clock frequency selection bit:
                            // - 0: Standard clock selected, Fsys/12.
                            // - 1: Fast clock selected. Fsys/4 (bTMR_CLK=0) or Fsys (bTMR_CLK=1).
SBIT(bT0_CLK,     0xC9, 4); // Timer0 internal clock frequency selection bit:
                            // - 0: Standard clock selected, Fsys/12.
                            // - 1: Fast clock selected, Fsys/4 (bTMR_CLK=0) or Fsys (bTMR_CLK=1).
SBIT(bT2_CAP_M1,  0xC9, 3); // Timer2 capture mode high bit.
SBIT(bT2_CAP_M0,  0xC9, 2); // Timer2 capture mode low bit.
SBIT(T2OE,        0xC9, 1); // Timer2 clock output enable bit:
                            // - 0: Output disabled.
                            // - 1: T2 pin enabled to output clock. The frequency is the half of the Timer2 overflow rate.
SBIT(bT2_CAP1_EN, 0xC9, 0); // Capture 1 mode enable when RCLK=0, TCLK=0, CP_RL2=1, C_T2=0 and T2OE=0:
                            // - 1: Capture 1 function enabled. Active edge on T2 is captured.
                            // - 0: Capture 1 function disabled.

// Pin Function Selection Register (PIN_FUNC):
SBIT(bUSB_IO_EN,   0xC6, 7); // USB UDP/UDM pin enable bit:
                             // - 0: P3.6/P3.7 selected for GPIO. P3_DIR_PU can be used to control pull-up resistor, and P3_MOD_OC is supported.
                             // - 1: P3.6/P3.7 selected for UDP/UDM, controlled by USB module, and P3_DIR_PU and P3_MOD_OC both have no effect on it.
SBIT(bIO_INT_ACT,  0xC6, 6); // GPIO interrupt request activation status: When bIE_IO_EDGE=0:
                             // - 1: GPIO inputs valid level and interrupts the request.
                             // - 0: Input level is invalid. When bIE_IO_EDGE=1, the bit is used as the edge interrupt flag, 1: Valid edge is detected and the bit cannot be reset by software and can only be reset automatically in reset or level interrupt mode or when entering the corresponding interrupt service program.
SBIT(bUART1_PIN_X, 0xC6, 5); // UART1 pin mapping enable bit:
                             // - 0: RXD1/TXD1 selects P1.6/P1.7.
                             // - 1: RXD1/TXD1 selects P3.4/P3.2
SBIT(bUART0_PIN_X, 0xC6, 4); // UART1 pin mapping enable bit:
                             // - 0: RXD1/TXD1 selects P1.6/P1.7.
                             // - 1: RXD1/TXD1 selects P3.4/P3.2
SBIT(bPWM2_PIN_X,  0xC6, 3); // PWM2 pin mapping enable bit:
                             // - 0: PWM2 selects P3.4.
                             // - 1: PWM2 selects P3.1
SBIT(bPWM1_PIN_X,  0xC6, 2); // PWM1 pin mapping enable bit:
                             // - 0: PWM1 selects P1.5.
                             // - 1: PWM1 selects P3.0
SBIT(bT2EX_PIN_X,  0xC6, 1); // T2EX/CAP2 pin mapping enable bit:
                             // - 0: T2EX/CAP2 selects P1.1.
                             // - 1: T2EX/CAP2 selects RST
SBIT(bT2_PIN_X,    0xC6, 0); // T2/CAP1 pin mapping enable bit:
                             // - 0: T2/CAP1 selects P1.0.
                             // - 1: T2/CAP1 selects P1.4

// P3 Port
SBIT(P30, 0xB0, 0);   // p3.0
SBIT(P31, 0xB0, 1);   // p3.1
SBIT(P32, 0xB0, 2);   // p3.2
SBIT(P33, 0xB0, 3);   // p3.3
SBIT(P34, 0xB0, 4);   // p3.4
SBIT(P35, 0xB0, 5);   // p3.5
SBIT(P36, 0xB0, 6);   // p3.6
SBIT(P37, 0xB0, 7);   // p3.7

// PWM control register (PWM_CTRL):
SBIT(bPWM_IE_END,  0x9D, 7); // PWM cycle end or MFM buffer interrupt enabled.
SBIT(bPWM2_POLAR,  0x9D, 6); // PWM2 output polarity control bit:
                             // - 0: Low level by default while active high.
                             // - 1: High level by default while active low.
SBIT(bPWM1_POLAR,  0x9D, 5); // PWM1 output polarity control bit:
                             // - 0: Low level by default while active high.
                             // - 1: High level by default while active low.
SBIT(bPWM_IF_END,  0x9D, 4); // PWM cycle period end interrupt flag bit:
                             // - 1: A PWM cycle period end interrupt. Write 1 to reset, or reset when the PWM_DATA1 data is reloaded.
SBIT(bPWM2_OUT_EN, 0x9D, 3); // PWM2 output enable:
                             // - 1: PWM2 output enabled
SBIT(bPWM1_OUT_EN, 0x9D, 2); // PWM1 output enable:
                             // - 1: PWM1 output enabled
SBIT(bPWM_CLR_ALL, 0x9D, 1); // Empty PWM1 and PWM2 counts and FIFO.

#endif
